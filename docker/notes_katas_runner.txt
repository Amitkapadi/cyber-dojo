
DockerTmpRunner - DockerKatasRunner
------------------------------------
Both need to write to katas/ but only to save results.
Be that via a data-container or a volume-mount
Be that via a microservice or not


But KatasRunner also needs to *read* from katas/

One issue is: what are the date-time stamps on the files inside the run-container?
o) tmp-runner   == brand new
o) katas-runner == as from last time if the file didn't change

One issue is: what files are actually inside the run-container?
o) tmp-runner   == only the visible files.
o) katas-runner == everything, .o file, executables, etc.

What are the trade offs?

B = Browser
V = volume on host
D = data-container
L = local volume
R = run-container
P = tar-pipe

katas-volume-runner
-------------------
changed files are copied into katas/...
cyber-dojo.sh run directly in katas/... inside container
   - uid dependency on host
   - direct coupling between the runner and the katas/... folder (volume mount)
        - katas/ holds src files and intermediates (eg .o files)
   - file copying
        - 1st B       -> V:katas/... (changed only, preserve date-time stamps) RUN+DIFF
        - <<RUN>>
        - 2nd output  -> V:katas/...
        - <<GIT-COMMIT>>
        - 3rd output  -> B


katas-data-container-runner (can't volume-mount)
---------------------------
changed files are copied into katas sub-folder
*all* files in katas/... are tar piped into container in tmp/...
cyber-dojo.sh runs in tmp/... inside container
*all* files in container in tmp/... are tar|piped *back* to katas/...
    - no uid dependency on host
    - indirect coupling between runner and katas/... (via path argument)
        - katas holds src files and extra files (eg .o files, executables)
    - file copying
        - 1st B           -> D:katas/... (changed only, preserve date-time stamps)
      P - 2nd D:katas/... -> R:tmp/...   (all)
        - <<RUN>>
      P - 3rd R:tmp/...   -> D:katas/... (all, preserve data-time stamps) <<<<<< TO PROVE <<<<<<<<
        - 4th output      -> D:katas
        - <<GIT-COMMIT>>
        - 5rd output      -> B
    STEP 3 IS THE CRUCIAL ONE.
    It means it's possible to avoid the volume-mount and still get
    incremental builds. This is an important use case for James.
    Not using a volume-mount means there is no dependency on hosts cyber-dojo uid
    and ownership of katas volume. Price is extra copying.
    Note that each git commit only commits visible files.
    The extra files only live 'once' in the sandbox
    Price is extra copying. Two tar pipes. Checked with James and typical
    exercise he uses (with incremental builds) has tar file of 1.6MB.
    Zipped its 400K
    Incremental build is less than one second  (23-42 ms)
    Full build is about 3-4 seconds. (1904-2568-2873 ms)
    This looks promising.


tmp-runner
----------
all files are copied into tmp/...
*all* files in tmp/... are tar piped into tmp/... in container
cyber-dojo.sh runs in tmp/... inside container
output returned
    - elsewhere output and (changed) files saved to katas
        - katas could be volume-mount on host
        - katas could be data container
    - no uid dependency on host
    - no coupling between runner and katas/...
    - file copying
        - 1st B         -> L:tmp/... (all, date-time stamps are new)
        - 2nd L:tmp/... -> C:tmp/... (all)
          <<RUN>>
        - 3rd B         -> KATAS
        - 4th output    -> KATAS
          <<GIT_COMMIT>>
        - 5th output    -> B



So I can preserve incremental makes and not have a user+uid
dependency on the host. Not that its such a big dependency.
And in its place I have to create a data container from the
katas/ folder. That makes it tricker to get at the data.
Might make it easier to accidentally delete the data container.

But thinking a good option is to just support a katas-data-container
and have no volume-mounting at all


katas-data-container runner
---------------------------
Looks promising. Might become the default!
Could then be only two runners, both using katas, one from data-container,
one from volume-mount. Former has to tar-pipe in both directions (for
security if no other reason because you can't get sub-folder restriction)
Later does not tar-pipe in either direction. volume-mount can give sub-folder
restriction.

Only if the test completes in 10 seconds are the files are tar piped
directly back to their katas sub-folder. No tar file ever actually exists.
The test run becomes atomic!
If the test does not complete in 10 seconds then it as if the attempt was never made.
The only visible change is the date-time stamp (and contents) of the visible-files
copied into katas/... before the test run.
What about rights/ownership of files?
The files inside the test-container will be owned by nobody. That should
be fine, incremental makes rely on time-stamps not owner.
The files outside the test-container (katas data container) will be owned by
cyber-dojo the rails app is running as.

Note that a consequence of this is that katas-data-container will fill up
quicker because it will contains executable, .o, .a, .lib etc files.
Files created *during* the test.
