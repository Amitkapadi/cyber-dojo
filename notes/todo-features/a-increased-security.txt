

PORTS
------
See lib/DockerTestRunner.rb option
--net="none"


USER
----
See lib/DockerTestRunner.rb option
-u www-data


TIMING
------
The timeout command runs *inside* the docker
container. This presents a potential security flaw
since from inside the container the timeout could
perhaps be disabled. If the timeout happens on the outside
then the docker-run command is not terminated cleanly
(when there is an infinite loop) and still-running docker
containers remain. This is presumably because the --rm
option is not being obeyed.
An answer is to have a timeout on both the inside
*and* the outside and to use the --cidfile option.

Inside: If the inner timeout is not broken out of
  then if inner timeout happens (infinite loop)
  the --rm option works and shuts the docker
  container down.
Outside: If the inner timeout is broken out of
  then outer timeout will occur. However the
  --rm will not take effect and the docker container
  will not have been shut down. Thus the outer
  command requires the --cidfile option so the
  docker container can be shutdown.

How to test this?
How to simulate breaking out of the outer timeout?
Simply set the outer timeout to 5 seconds (say)
and the inner timeout to 10 seconds (say) and arrange
for an infinite loop inside the container.
This forces the outer timeout to signal its kill signal.
When you do this
o) the server returns 137 (128+9)
o) docker ps -a -q reports a docker container still running
o) the cidfile contains the running container's ID

What about when the inner timeout is not broken
out of and timeouts out normally (eg infinite loop).
Set outer timeout to 10s and inner timeout to 5s.
When this happens
o) the server returns 124
o) docker ps -a -q reports no contains still running
o) the cidfile contains the ID of the properly closed down docker container


    require 'tempfile'

    def run(sandbox, command, max_seconds)
      inner_run(sandbox, timeout(command,max_seconds), max_seconds)
    end

    def inner_run(sandbox, command, max_seconds)
        cidfile = 'tmp/' + Dir::Tmpname.make_tmpname(['cidfile', '.txt'], {})

        language = sandbox.avatar.kata.language
        docker_command =
          "docker run" +
            " -u www-data" +
            " --cidfile="#{cidfile}" +
            " -v #{sandbox.path}:/sandbox:#{read_write}" +
            " -v #{language.path}:#{language.path}:#{read_only}" +
            " -w /sandbox" +
            " #{language.image_name}" +
            " /bin/bash -c " +
            "\"#{command}\""
        outer_command = timeout(docker_command,max_seconds+5)

        output = `#{outer_command}`
        exit_status = $?.exitstatus

        pid = `cat #{cidfile}`
        `rm #{cidfile}`
        `docker stop #{pid}`
        `docker rm #{pid}`

        exit_status != fatal_error(kill) ?
            limited(output,50*1024) :
            didnt_complete(max_seconds)
    end

    def timeout(command,after)
      "timeout --signal=#{kill} #{after}s #{stderr2stdout(command)}"
    end




CPU
---
Limit cpu option - want to do this so server's core
processes have priority in the face of an attack.


DISK
----
You can use tempFS as a proxy to an existing real
file system and this allows you to limit the amount
of disk space available.
https://goldmann.pl/blog/2014/09/11/resource-management-in-docker/
By default you get 10GB of space for each container
To change it
docker -d --storage-opt dm.basesize=5G
docker -d --storage-opt dm.basesize=5M
Then you need to restart the docker daemon
Tried this on DockerTestRunner - did not work.
Ok.
$ service docker stop
$ docker -d --storage-opt dm.basesize=5M &
This creates a lot of output.
But it works and stays running after you exit the server you
ssh'd into.
Can you create a docker config file which is looked at
to get options for the docker daemon?


RAM
---
Limit RAM option (and swap)
https://goldmann.pl/blog/2014/09/11/resource-management-in-docker/
-m 128M
Says
digital-ocean server says
WARNING: Your kernel does not support swap limit capabilities. Limitation discarded.
AWS server gives same warning.


//-------------------------------------

There is no valuable data on the file system.
But someone could escalate and then control the
server from which to launch attacks. I could then
be liable in some way.

Make a docker container for the whole server!
Only really makes sense if the outer container
can run containers inside itself. Rob mentioned
that it can.
